# 裸金属二进制翻译器的架构

显然，一个人在一年的时间内直接写一个系统级二进制翻译器，而且还需要直接运行在裸机上，
这种事情是不可能的。 MagiXen [^1] 是基于 IA-32 [^2] 开发的，所以我们在想基于什么进行二次开发。

一种想法是基于 Captive [^3] 进行开发，但是最后还是选择的是 QEMU ，原因主要是因为:
- Captive 不存在需要写 ArchC [^4] 来描述 x86 架构，这部分可能需要写超过 10000 行的代码。 [^5]
- 组里和龙芯公司，以及产业界有很多人都理解 QEMU，如果到时候出现了问题，可以更加容易的找人请教
- QEMU 的代码质量更加可靠，如果出现问题，那么一定是自己的问题

## 如何让 QEMU 运行在裸金属上
- QEMU 依赖了外部的库
  - 主要是 glibc 和 glib [^6]
  - 实际上，
- QEMU 调用了很多系统调用，这些系统调用需要操作系统的支持

## QEMU 被重构的部分
按照 interface.md 梳理一遍吧
- memory model
- thread
- option
- qom

[^5]: @todo 似乎在 Captive 的文章中说 arm 需要 8000 行，找到原文
