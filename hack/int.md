# 中断
<!-- vim-markdown-toc GitLab -->

* [追加上这些内容，然后彻底的理解中断系统了](#追加上这些内容然后彻底的理解中断系统了)
* [Question](#question)
* [doc](#doc)
* [TODO](#todo)
* [overview](#overview)
* [precise exception](#precise-exception)
* [ipi](#ipi)
* [timer](#timer)
* [irq](#irq)
* [irqaction](#irqaction)
* [tasklet](#tasklet)
* [pic](#pic)
* [apic](#apic)
* [request irq](#request-irq)
* [affinity](#affinity)
* [gpio](#gpio)
* [idt](#idt)
  * [Exception Handling](#exception-handling)
  * [Interrupt	Handling](#interrupthandling)
* [x86 vector](#x86-vector)
* [isa and pci](#isa-and-pci)
* [eoi](#eoi)
* [ioapic](#ioapic)
* [proc && sys](#proc-sys)
* [/proc/irq](#procirq)
* [/proc/interrupts](#procinterrupts)
* [matrix](#matrix)
* [nested interrupt](#nested-interrupt)
* [interrupt threads](#interrupt-threads)
* [stack](#stack)
* [interrupt context](#interrupt-context)
* [ret](#ret)
* [ref](#ref)

<!-- vim-markdown-toc -->

## 追加上这些内容，然后彻底的理解中断系统了
- 在用户态如何进行中断的平衡
  - https://github.com/Irqbalance/irqbalance
- 分析中断和各种锁的影响
- 分析中断和调度的影响 : preemption
- 在虚拟化中的中断

## Question
- [ ] 总结 从 ics 的中断 和 ucore 的中断的实现，然后再去分析
- [ ] fwnode 是做什么的 ?

[Irqbalance is a daemon to help balance the cpu load generated by interrupts across all of a systems cpus.](https://github.com/Irqbalance/irqbalance)

- [ ] handle level 和 handle edge 都是在搞什么?

## doc
1. coreboot 关于 x86 中断的三部曲:
  - Interrupt controller evolution : https://habr.com/ru/post/446312/
  - Linux kernel boot options : https://habr.com/ru/post/501660/
  - Interrupt routing setup in a chipset, with the example of coreboot : https://habr.com/en/post/501912/


## TODO
- [answer this question](https://unix.stackexchange.com/questions/491437/how-does-linux-kernel-switches-from-kernel-stack-to-interrupt-stack?rq=1)
- [ ] http://wiki.0xffffff.org/posts/hurlex-8.html : used for understand 8259APIC
- [ ] 总结从 idt 分别到 interrupt 和 exception 的过程
- [ ] 所以 CPU 为什么需要 debug 的 exception 啊 ?

- [ ] https://os.phil-opp.com/cpu-exceptions/#the-interrupt-stack-frame 和 insides 处理各种细节应该就可以了吧 !

- arm 的一些资料:
  - https://programming.vip/docs/linux-kernel-interrupt-implementation-principle.html
## overview
arch/x86/kernel/apic
| File             | blank | comment | code | explanation |
|------------------|-------|---------|------|-------------|
| io_apic.c        | 449   | 560     | 2063 |             |
| apic.c           | 413   | 758     | 1711 |             |
| x2apic_uv_x.c    | 274   | 107     | 1193 |             |
| vector.c         | 189   | 218     | 848  |             |
| msi.c            | 75    | 79      | 361  |             |
| apic_numachip.c  | 70    | 18      | 250  |             |
| ipi.c            | 55    | 68      | 208  |             |
| x2apic_cluster.c | 44    | 9       | 173  |             |
| apic_flat_64.c   | 48    | 35      | 168  |             |
| probe_32.c       | 38    | 25      | 152  |             |
| x2apic_phys.c    | 41    | 2       | 147  |             |
| bigsmp_32.c      | 41    | 13      | 138  |             |
| apic_noop.c      | 28    | 22      | 95   |             |
| local.h          | 12    | 16      | 41   |             |
| hw_nmi.c         | 7     | 11      | 41   |             |
| probe_64.c       | 7     | 13      | 35   |             |
| apic_common.c    | 7     | 5       | 34   |             |
| Makefile         | 6     | 9       | 15   |             |

kernel/irq
| file           | blank | comment | code | explanation |
|----------------|-------|---------|------|-------------|
| manage.c       | 309   | 678     | 1271 |             |
| irqdomain.c    | 242   | 412     | 1107 |             |
| chip.c         | 217   | 390     | 843  |             |
| irqdesc.c      | 157   | 127     | 661  |             |
| generic-chip.c | 92    | 144     | 412  |             |
| proc.c         | 92    | 52      | 385  |             |
| msi.c          | 76    | 92      | 357  |             |
| internals.h    | 73    | 60      | 348  |             |
| matrix.c       | 55    | 121     | 280  |             |
| spurious.c     | 58    | 160     | 247  |             |
| debugfs.c      | 45    | 8       | 220  |             |
| ipi.c          | 45    | 112     | 182  |             |
| affinity.c     | 44    | 44      | 182  |             |
| devres.c       | 39    | 98      | 150  |             |
| settings.h     | 27    | 5       | 137  |             |
| pm.c           | 32    | 56      | 124  |             |
| timings.c      | 41    | 197     | 124  |             |
| cpuhotplug.c   | 24    | 86      | 106  |             |
| handle.c       | 35    | 86      | 101  |             |
| irq_sim.c      | 25    | 43      | 95   |             |
| autoprobe.c    | 21    | 71      | 92   |             |
| migration.c    | 18    | 45      | 56   |             |
| resend.c       | 11    | 41      | 48   |             |
| debug.h        | 8     | 5       | 36   |             |
| dummychip.c    | 7     | 21      | 36   |             |
| Makefile       | 1     | 1       | 15   |             |


## precise exception
- [ ] see mips run : chapter 5

## ipi
https://stackoverflow.com/questions/62068750/kinds-of-ipi-for-x86-architecture-in-linux

## timer
- [ ] timer 应该是在 CPU 外部存在中断吧，从引脚信息到 lapic 到 scheduler 函数是如何处理的 ?

## irq
```c
struct irq_chip {
	struct device	*parent_device;     //指向父设备
	const char	*name;      //  /proc/interrupts中显示的名字
	unsigned int	(*irq_startup)(struct irq_data *data);  //启动中断，如果设置成NULL，则默认为enable
	void		(*irq_shutdown)(struct irq_data *data);     //关闭中断，如果设置成NULL，则默认为disable
	void		(*irq_enable)(struct irq_data *data);   //中断使能，如果设置成NULL，则默认为chip->unmask
	void		(*irq_disable)(struct irq_data *data);  //中断禁止

	void		(*irq_ack)(struct irq_data *data);  //开始新的中断
	void		(*irq_mask)(struct irq_data *data); //中断源屏蔽
	void		(*irq_mask_ack)(struct irq_data *data); //应答并屏蔽中断
	void		(*irq_unmask)(struct irq_data *data);   //解除中断屏蔽
	void		(*irq_eoi)(struct irq_data *data);  //中断处理结束后调用

	int		(*irq_set_affinity)(struct irq_data *data, const struct cpumask *dest, bool force); //在SMP中设置CPU亲和力
	int		(*irq_retrigger)(struct irq_data *data);    //重新发送中断到CPU
	int		(*irq_set_type)(struct irq_data *data, unsigned int flow_type); //设置中断触发类型
	int		(*irq_set_wake)(struct irq_data *data, unsigned int on);    //使能/禁止电源管理中的唤醒功能

	void		(*irq_bus_lock)(struct irq_data *data); //慢速芯片总线上的锁
	void		(*irq_bus_sync_unlock)(struct irq_data *data);  //同步释放慢速总线芯片的锁

	void		(*irq_cpu_online)(struct irq_data *data);
	void		(*irq_cpu_offline)(struct irq_data *data);

	void		(*irq_suspend)(struct irq_data *data);
	void		(*irq_resume)(struct irq_data *data);
	void		(*irq_pm_shutdown)(struct irq_data *data);

	void		(*irq_calc_mask)(struct irq_data *data);

	void		(*irq_print_chip)(struct irq_data *data, struct seq_file *p);
	int		(*irq_request_resources)(struct irq_data *data);
	void		(*irq_release_resources)(struct irq_data *data);

	void		(*irq_compose_msi_msg)(struct irq_data *data, struct msi_msg *msg);
	void		(*irq_write_msi_msg)(struct irq_data *data, struct msi_msg *msg);

	int		(*irq_get_irqchip_state)(struct irq_data *data, enum irqchip_irq_state which, bool *state);
	int		(*irq_set_irqchip_state)(struct irq_data *data, enum irqchip_irq_state which, bool state);

	int		(*irq_set_vcpu_affinity)(struct irq_data *data, void *vcpu_info);

	void		(*ipi_send_single)(struct irq_data *data, unsigned int cpu);
	void		(*ipi_send_mask)(struct irq_data *data, const struct cpumask *dest);

	unsigned long	flags;
};

struct irq_domain {
	struct list_head link;  //用于添加到全局链表irq_domain_list中
	const char *name;   //IRQ domain的名字
	const struct irq_domain_ops *ops;   //IRQ domain映射操作函数集
	void *host_data;    //在GIC驱动中，指向了irq_gic_data
	unsigned int flags;
	unsigned int mapcount;  //映射中断的个数

	/* Optional data */
	struct fwnode_handle *fwnode;
	enum irq_domain_bus_token bus_token;
	struct irq_domain_chip_generic *gc;
#ifdef	CONFIG_IRQ_DOMAIN_HIERARCHY
	struct irq_domain *parent;  //支持级联的话，指向父设备
#endif
#ifdef CONFIG_GENERIC_IRQ_DEBUGFS
	struct dentry		*debugfs_file;
#endif

	/* reverse map data. The linear map gets appended to the irq_domain */
	irq_hw_number_t hwirq_max;  //IRQ domain支持中断数量的最大值
	unsigned int revmap_direct_max_irq;
	unsigned int revmap_size;   //线性映射的大小
	struct radix_tree_root revmap_tree; //Radix Tree映射的根节点
	unsigned int linear_revmap[];   //线性映射用到的查找表
};

struct irq_domain_ops {
	int (*match)(struct irq_domain *d, struct device_node *node,
		     enum irq_domain_bus_token bus_token);      // 用于中断控制器设备与IRQ domain的匹配
	int (*select)(struct irq_domain *d, struct irq_fwspec *fwspec,
		      enum irq_domain_bus_token bus_token);
	int (*map)(struct irq_domain *d, unsigned int virq, irq_hw_number_t hw);    //用于硬件中断号与Linux中断号的映射
	void (*unmap)(struct irq_domain *d, unsigned int virq);
	int (*xlate)(struct irq_domain *d, struct device_node *node,
		     const u32 *intspec, unsigned int intsize,
		     unsigned long *out_hwirq, unsigned int *out_type);     //通过device_node，解析硬件中断号和触发方式

#ifdef	CONFIG_IRQ_DOMAIN_HIERARCHY
	/* extended V2 interfaces to support hierarchy irq_domains */
	int (*alloc)(struct irq_domain *d, unsigned int virq,
		     unsigned int nr_irqs, void *arg);
	void (*free)(struct irq_domain *d, unsigned int virq,
		     unsigned int nr_irqs);
	void (*activate)(struct irq_domain *d, struct irq_data *irq_data);
	void (*deactivate)(struct irq_domain *d, struct irq_data *irq_data);
	int (*translate)(struct irq_domain *d, struct irq_fwspec *fwspec,
			 unsigned long *out_hwirq, unsigned int *out_type);
#endif
};

/**
 * struct irq_data - per irq chip data passed down to chip functions
 * @mask:		precomputed bitmask for accessing the chip registers
 * @irq:		interrupt number
 * @hwirq:		hardware interrupt number, local to the interrupt domain
 * @common:		point to data shared by all irqchips
 * @chip:		low level interrupt hardware access
 * @domain:		Interrupt translation domain; responsible for mapping
 *			between hwirq number and linux irq number.
 * @parent_data:	pointer to parent struct irq_data to support hierarchy
 *			irq_domain
 * @chip_data:		platform-specific per-chip private data for the chip
 *			methods, to allow shared chip implementations
 */
struct irq_data {
	u32			mask;
	unsigned int		irq;
	unsigned long		hwirq;
	struct irq_common_data	*common;
	struct irq_chip		*chip;
	struct irq_domain	*domain;
#ifdef	CONFIG_IRQ_DOMAIN_HIERARCHY
	struct irq_data		*parent_data;
#endif
	void			*chip_data;
};
```

![img](https://img2020.cnblogs.com/blog/1771657/202005/1771657-20200531111554895-528341955.png)
- `struct irq_chip`结构，描述的是中断控制器的底层操作函数集，这些函数集最终完成对控制器硬件的操作；
- `struct irq_domain`结构，用于硬件中断号和Linux IRQ中断号（virq，虚拟中断号）之间的映射；
- `irq_chip` 结构体中的每个函数指针，都会携带一个指向struct irq_data的指针作为参数


![img](https://img2020.cnblogs.com/blog/1771657/202005/1771657-20200531111647851-1005315068.png)

- 每个中断控制器都对应一个IRQ Domain；
- 中断控制器驱动通过`irq_domain_add_*()`接口来创建IRQ Domain；
- IRQ Domain支持三种映射方式：linear map（线性映射），tree map（树映射），no map（不映射）；
  - linear map：维护固定大小的表，索引是硬件中断号，如果硬件中断最大数量固定，并且数值不大，可以选择线性映射；
  - tree map：硬件中断号可能很大，可以选择树映射；
  - no map：硬件中断号直接就是Linux的中断号；

![](https://img2020.cnblogs.com/blog/1771657/202005/1771657-20200531111718514-879227841.png)

![](https://img2020.cnblogs.com/blog/1771657/202005/1771657-20200531111755704-1231972965.png)

## irqaction
```c
/**
 * struct irqaction - per interrupt action descriptor
 * @handler:	interrupt handler function
 * @name:	name of the device
 * @dev_id:	cookie to identify the device
 * @percpu_dev_id:	cookie to identify the device
 * @next:	pointer to the next irqaction for shared interrupts
 * @irq:	interrupt number
 * @flags:	flags (see IRQF_* above)
 * @thread_fn:	interrupt handler function for threaded interrupts
 * @thread:	thread pointer for threaded interrupts
 * @secondary:	pointer to secondary irqaction (force threading)
 * @thread_flags:	flags related to @thread
 * @thread_mask:	bitmask for keeping track of @thread activity
 * @dir:	pointer to the proc/irq/NN/name entry
 */
struct irqaction {
	irq_handler_t		handler;
	void			*dev_id;
	void __percpu		*percpu_dev_id;
	struct irqaction	*next;
	irq_handler_t		thread_fn;
	struct task_struct	*thread;
	struct irqaction	*secondary;
	unsigned int		irq;
	unsigned int		flags;
	unsigned long		thread_flags;
	unsigned long		thread_mask;
	const char		*name;
	struct proc_dir_entry	*dir;
} ____cacheline_internodealigned_in_smp;
```

- [ ] /proc/interrupts : proc.c:show_interrupts() 的最后的描述，其实就是相关的 chip
```
            CPU0       CPU1       CPU2       CPU3       CPU4       CPU5       CPU6       CPU7
   0:          8          0          0          0          0          0          0          0  IR-IO-APIC    2-edge      timer
   1:      19619          0          0          0          0          0          0       3444  IR-IO-APIC    1-edge      i8042
   8:          0          1          0          0          0          0          0          0  IR-IO-APIC    8-edge      rtc0
   9:         46         68          0          0          0          0          0          0  IR-IO-APIC    9-fasteoi   acpi
  12:        384          0          0          0          0          0        143          0  IR-IO-APIC   12-edge      i8042
  14:     187427          0      28041          0          0          0          0          0  IR-IO-APIC   14-fasteoi   INT344B:00
```


## tasklet
在 softirq 上的封装：

- [ ] https://lwn.net/Articles/830964/
- [ ] https://www.cnblogs.com/LoyenWang/p/13124803.html

## pic
Interrupt	sequence:
– Interrupt	controller	raises	INT	line
– 80386	core	pulses	INTA	line	low,	allowing	INT	to	go	low
– 80386	core	pulses	INTA	line	low	again,	signaling	controller	to put	interrupt	number	on	data	bus

> 一共三根线 : interrupt line, interrupt acknowledge line, Data bus 参与

## apic
- [ ] https://habr.com/en/post/446312/
```c
// global apic variable
struct apic *apic __ro_after_init = &apic_flat;
```
- [ ] [^3]p117 的 IO APIC 的 24 个引脚的寄存器配置


- [ ] apic, timer and **LVIT**
  - [ ] what's LVIT ?
```c
/* 进入到 arch/x86/kernel/apic/apic.c 了 */
// 好吧，就是向 apic 控制器写入寄存器之类的操作 !

/*
 * The local apic timer can be used for any function which is CPU local.
 */
static struct clock_event_device lapic_clockevent = {
	.name				= "lapic",
	.features			= CLOCK_EVT_FEAT_PERIODIC |
					  CLOCK_EVT_FEAT_ONESHOT | CLOCK_EVT_FEAT_C3STOP
					  | CLOCK_EVT_FEAT_DUMMY,
	.shift				= 32,
	.set_state_shutdown		= lapic_timer_shutdown,
	.set_state_periodic		= lapic_timer_set_periodic,
	.set_state_oneshot		= lapic_timer_set_oneshot,
	.set_state_oneshot_stopped	= lapic_timer_shutdown,
	.set_next_event			= lapic_next_event,
	.broadcast			= lapic_timer_broadcast,
	.rating				= 100,
	.irq				= -1,
};


static int lapic_timer_set_oneshot(struct clock_event_device *evt)
{
	return lapic_timer_set_periodic_oneshot(evt, true);
}

static inline int
lapic_timer_set_periodic_oneshot(struct clock_event_device *evt, bool oneshot)
{
	/* Lapic used as dummy for broadcast ? */
	if (evt->features & CLOCK_EVT_FEAT_DUMMY)
		return 0;

	__setup_APIC_LVTT(lapic_timer_period, oneshot, 1);
	return 0;
}
```

## request irq
devm_request_threaded_irq ==> request_threaded_irq

![loading](https://img2020.cnblogs.com/blog/1771657/202006/1771657-20200605223042609-247616444.png)
- [ ] 上面讲解了 thread ，shared 的处理，问题是，参数 irq 必须找到对应的 irq_desc, 新分配的只是 irq_action
    - [ ] 通过 irq_domain_alloc_descs 可以分配 irq_desc, 但是现在找不到这些函数的调用位置

## affinity

```c
static int __init irq_affinity_setup(char *str)
static void __init init_irq_default_affinity(void)


static int alloc_masks(struct irq_desc *desc, int node)
static void free_masks(struct irq_desc *desc)
```
> cpu mask 的功能好神奇 ? 还可以实现什么功能

## gpio
https://github.com/Manawyrm/pata-gpio


## idt
Vectors	usually	IRQ#+	32[^6]:
– Below	32	reserved	for	non-maskable	intr	&	excepWons
– Maskable	interrupts	can	be	assigned	as	needed
– Vector	128	used	for	syscall
– Vectors	251-255	used	for	IPI

- [ ] 简单验证一下 IRQ#+32 ，也就是在 idt 中间存在偏移量

IDT:	gate	descriptors,	one	per	vector[^6]
– Address	of	handler
– Current	Privilege	Level	(CPL)
– Descriptor	Privilege	Level	(DPL)
– Gates	(slightly	different	ways	of	entering	kernel)
    - Task	gate:	includes	TSS	to	transfer	to	(not	used	by Linux)
    - Interrupt	gate:	disables	further	interrupts
    - Trap	gate:	further	interrupts	sWll	allowed

- [ ] CPL 和 DPL : DPL 不总是内核态吗 ? 难道还可以在用户态执行 handler ?
    - [ ] 是不是可以根据 CPL 的不同，操作不同，比如切换到内核态的 stack
- [ ] Interrupt gate 和 Trap gate 的唯一区别就是是否 disable interrupt 吗 ？


- arch/x86/include/asm/idtentry.h
- arch/x86/kernel/irq.c

- [x] DEFINE_IDTENTRY_IRQ : interesting, wrap interrupt handler with `irq_enter_rcu`, `irq_exit_rcu` and `irqentry_exit`

```c
/*
 * common_interrupt() handles all normal device IRQ's (the special SMP
 * cross-CPU interrupts have their own entry points).
 */
DEFINE_IDTENTRY_IRQ(common_interrupt)
```

- [x] How exception are set
```c
/*
 * Dummy trap number so the low level ASM macro vector number checks do not
 * match which results in emitting plain IDTENTRY stubs without bells and
 * whistels.
 */
#define X86_TRAP_OTHER		0xFFFF

/* Simple exception entry points. No hardware error code */
DECLARE_IDTENTRY(X86_TRAP_DE,		exc_divide_error);
DECLARE_IDTENTRY(X86_TRAP_OF,		exc_overflow);
DECLARE_IDTENTRY(X86_TRAP_BR,		exc_bounds);
DECLARE_IDTENTRY(X86_TRAP_NM,		exc_device_not_available);
DECLARE_IDTENTRY(X86_TRAP_OLD_MF,	exc_coproc_segment_overrun);
DECLARE_IDTENTRY(X86_TRAP_SPURIOUS,	exc_spurious_interrupt_bug);
DECLARE_IDTENTRY(X86_TRAP_MF,		exc_coprocessor_error);
DECLARE_IDTENTRY(X86_TRAP_XF,		exc_simd_coprocessor_error);

/* 32bit software IRET trap. Do not emit ASM code */
DECLARE_IDTENTRY_SW(X86_TRAP_IRET,	iret_error);

/* Simple exception entries with error code pushed by hardware */
DECLARE_IDTENTRY_ERRORCODE(X86_TRAP_TS,	exc_invalid_tss);
DECLARE_IDTENTRY_ERRORCODE(X86_TRAP_NP,	exc_segment_not_present);
DECLARE_IDTENTRY_ERRORCODE(X86_TRAP_SS,	exc_stack_segment);
DECLARE_IDTENTRY_ERRORCODE(X86_TRAP_GP,	exc_general_protection);
DECLARE_IDTENTRY_ERRORCODE(X86_TRAP_AC,	exc_alignment_check);

/* Raw exception entries which need extra work */
DECLARE_IDTENTRY_RAW(X86_TRAP_UD,		exc_invalid_op);
DECLARE_IDTENTRY_RAW(X86_TRAP_BP,		exc_int3);
DECLARE_IDTENTRY_RAW_ERRORCODE(X86_TRAP_PF,	exc_page_fault);
```

```c
/*
 * The default IDT entries which are set up in trap_init() before
 * cpu_init() is invoked. Interrupt stacks cannot be used at that point and
 * the traps which use them are reinitialized with IST after cpu_init() has
 * set up TSS.
 */
static const __initconst struct idt_data def_idts[] = {
	INTG(X86_TRAP_DE,		asm_exc_divide_error),
	INTG(X86_TRAP_NMI,		asm_exc_nmi),
	INTG(X86_TRAP_BR,		asm_exc_bounds),
	INTG(X86_TRAP_UD,		asm_exc_invalid_op),
	INTG(X86_TRAP_NM,		asm_exc_device_not_available),
	INTG(X86_TRAP_OLD_MF,		asm_exc_coproc_segment_overrun),
	INTG(X86_TRAP_TS,		asm_exc_invalid_tss),
	INTG(X86_TRAP_NP,		asm_exc_segment_not_present),
	INTG(X86_TRAP_SS,		asm_exc_stack_segment),
	INTG(X86_TRAP_GP,		asm_exc_general_protection),
	INTG(X86_TRAP_SPURIOUS,		asm_exc_spurious_interrupt_bug),
	INTG(X86_TRAP_MF,		asm_exc_coprocessor_error),
	INTG(X86_TRAP_AC,		asm_exc_alignment_check),
	INTG(X86_TRAP_XF,		asm_exc_simd_coprocessor_error),

#ifdef CONFIG_X86_32
	TSKG(X86_TRAP_DF,		GDT_ENTRY_DOUBLEFAULT_TSS),
#else
	INTG(X86_TRAP_DF,		asm_exc_double_fault),
#endif
	INTG(X86_TRAP_DB,		asm_exc_debug),

#ifdef CONFIG_X86_MCE
	INTG(X86_TRAP_MC,		asm_exc_machine_check),
#endif

	SYSG(X86_TRAP_OF,		asm_exc_overflow),
#if defined(CONFIG_IA32_EMULATION)
	SYSG(IA32_SYSCALL_VECTOR,	entry_INT80_compat),
#elif defined(CONFIG_X86_32)
	SYSG(IA32_SYSCALL_VECTOR,	entry_INT80_32),
#endif
};
```

### Exception Handling
[^6]
- Most	error	excepWons	—	divide by zero,	invalid operation,	illegal	memory	reference,	etc.	—	translate directly	into	signals: `force_sig(sig_number,	current);`
- An exception	can	(infrequently)	happen	in	the	kernel : `die()`;	//	kernel	oops

- [ ] 之前疑惑于为什么 debug 需要 exception 中间的 debug handler, 比如 software breakpint 采用将目标指令替换为 `int 3`
  - https://stackoverflow.com/questions/14031930/how-to-break-on-instruction-with-a-specific-opcode-in-gdb/31249378#31249378

### Interrupt	Handling
asm_common_interrupt => handle_irq => run_irq_on_irqstack_cond

```c
static __always_inline void
run_irq_on_irqstack_cond(void (*func)(struct irq_desc *desc), struct irq_desc *desc,
			 struct pt_regs *regs)
{
	lockdep_assert_irqs_disabled();

	if (irq_needs_irq_stack(regs))
		__run_irq_on_irqstack(func, desc);
	else
		func(desc);
}
```

- [ ] irq_desc::handler
    - [ ] `__irq_do_set_handler` : currently this is only function where irq_desc::handler is set


```c
const struct irq_domain_ops mp_ioapic_irqdomain_ops = {
	.alloc		= mp_irqdomain_alloc,
	.free		= mp_irqdomain_free,
	.activate	= mp_irqdomain_activate,
	.deactivate	= mp_irqdomain_deactivate,
};
```
mp_irqdomain_alloc ==> mp_register_handler ==> `__irq_set_handler` ==> `__irq_do_set_handler`


`__irq_domain_alloc_irqs` ==> irq_domain_alloc_irqs_hierarchy



## x86 vector
arch/x86/kernel/irqinit.c

with irq domain, we can map *linux irq* and *hw irq*,
`vector_irq_t` maps interrupt number ==> irq_desc, used in `common_interrupt`

```c
DEFINE_PER_CPU(vector_irq_t, vector_irq) = {
	[0 ... NR_VECTORS - 1] = VECTOR_UNUSED,
};
```

- [x] how interrupt are seted in idt
    - **idt_setup_apic_and_irq_gates**
- [ ] how interrupt are set in vector_irq
  - [ ] lapic_online : irq and desc relation already setup, *find* out when they are setup.

assign_irq_vector ==> assign_vector_locked

此外，arch_early_irq_init 中间初始化的默认 fwnode 以及 irq_domain 都是叫做 vector 的:
```c
int __init arch_early_irq_init(void)
{
	struct fwnode_handle *fn;

	fn = irq_domain_alloc_named_fwnode("VECTOR");
	BUG_ON(!fn);
	x86_vector_domain = irq_domain_create_tree(fn, &x86_vector_domain_ops,
						   NULL);
	BUG_ON(x86_vector_domain == NULL);
	irq_set_default_host(x86_vector_domain);

	BUG_ON(!alloc_cpumask_var(&vector_searchmask, GFP_KERNEL));

	/*
	 * Allocate the vector matrix allocator data structure and limit the
	 * search area.
	 */
	vector_matrix = irq_alloc_matrix(NR_VECTORS, FIRST_EXTERNAL_VECTOR,
					 FIRST_SYSTEM_VECTOR);
	BUG_ON(!vector_matrix);

	return arch_early_ioapic_init();
}
```



## isa and pci
[^1]:
ISA and PCI handle interrupts very differently. ISA expansion cards are configured manually for IRQ, usually by setting a jumper, but sometimes by running a setup program. All ISA slots have all IRQ lines present, so it doesn’t matter which card is placed in which slot. ISA cards use edge-sensitive interrupts, which means that an ISA device asserts a voltage on one of the interrupt lines to generate an interrupt. That in turn means that ISA devices cannot share interrupts because when the processor senses voltage on a particular interrupt line, it has no way to determine which of multiple devices might be asserting that interrupt. For ISA slots and devices, the rule is simple: two devices cannot share an IRQ if there is any possibility that those two devices may be used simultaneously. In practice that means that you cannot assign the same IRQ to more than one ISA device.

PCI cards use level-sensitive interrupts, which means that different PCI devices can assert different voltages on the same physical interrupt line, allowing the processor to determine which device generated the interrupt. PCI cards and slots manage interrupts internally. A PCI bus normally supports a maximum of four PCI slots, numbered 1 through 4. Each PCI slot can access four interrupts, labeled INT#1 through INT#4 (or INT#A through INT#D). Ordinarily, INT#1/A is used by PCI Slot 1, INT#2/B by Slot 2, and so on.


## eoi
https://stackoverflow.com/questions/7005331/difference-between-io-apic-fasteoi-and-io-apic-edge

## ioapic
- [ ] io apic 寄存器 && Redirection Table

Interrupt	routing[^6]:
– Allows	broadcast	or	selecWve	rouWng	of	interrupts
– Ability	to	distribute	interrupt	handling	load
– Routes	to	lowest	priority	process
  - Special	register:	Task	Priority	Register	(TPR)
– Arbitrates	(round-robin)	if	equal	priority

- [ ] 通过 TPR 可以实现将消息发送到 priority 最低的位置
## proc && sys
知道的 irq 在 proc 和 sys 下提供的接口 :

- [ ] /proc/irq
- [ ] /proc/softirq
- [ ] /proc/interrupts
- [ ] /sys/kernel/irq

- [ ] /sys/kernel/irq 和 /proc/irq 的关系是什么 ?

## /proc/irq
- [x] 代码跟踪 : 如何利用 /proc/irq 调整 io apic 的 cpu affinity
  - 最后就是调用到 irq_chip::irq_set_affinity 的位置
  - 并且和[^3] 中间描述的 ioapic 的中断选项完全相同

> affinity :
>   - IRQ affinity on SMP. If this is an IPI related irq, then this is the mask of the CPUs to which an IPI can be sent.
> effective_affinity :
>  - The effective IRQ affinity on SMP as some irq chips do not allow multi CPU destinations. A subset of affinity.

```c
static struct irq_chip ioapic_ir_chip __read_mostly = {
	.name			= "IR-IO-APIC",
	.irq_startup		= startup_ioapic_irq,
	.irq_mask		= mask_ioapic_irq,
	.irq_unmask		= unmask_ioapic_irq,
	.irq_ack		= irq_chip_ack_parent,
	.irq_eoi		= ioapic_ir_ack_level,
	.irq_set_affinity	= ioapic_set_affinity,
	.irq_retrigger		= irq_chip_retrigger_hierarchy,
	.irq_get_irqchip_state	= ioapic_irq_get_chip_state,
	.flags			= IRQCHIP_SKIP_SET_WAKE,
};
```



- /proc/irq 的代码都在 kernel/irq/proc.c

## /proc/interrupts
```txt
➜  irq cat /proc/interrupts
            CPU0       CPU1       CPU2       CPU3       CPU4       CPU5       CPU6       CPU7
   0:          8          0          0          0          0          0          0          0  IR-IO-APIC    2-edge      timer
   1:       2716          0          0          0          0          0          0         14  IR-IO-APIC    1-edge      i8042
   8:          0          1          0          0          0          0          0          0  IR-IO-APIC    8-edge      rtc0
   9:          4         13          0          0          0          0          0          0  IR-IO-APIC    9-fasteoi   acpi
  12:         83          0          0          0          0          0        143          0  IR-IO-APIC   12-edge      i8042
  14:     134097          0         31          0          0          0          0          0  IR-IO-APIC   14-fasteoi   INT344B:00
  16:    1381211          0          0       1125          0          0          0          0  IR-IO-APIC   16-fasteoi   idma64.0, i801_smbus, i2c_designware.0
  17:          0          0          0          0          0          0          0          0  IR-IO-APIC   17-fasteoi   idma64.1, i2c_designware.1
 120:          0          0          0          0          0          0          0          0  DMAR-MSI    0-edge      dmar0
 121:          0          0          0          0          0          0          0          0  DMAR-MSI    1-edge      dmar1
 122:          0          0          0          0          0          0          0          0  IR-PCI-MSI 458752-edge      PCIe PME, aerdrv
 123:          0          0          0          0          0          0          0          0  IR-PCI-MSI 473088-edge      PCIe PME, aerdrv
 124:          0          0          0          0          0          0          0          0  IR-PCI-MSI 475136-edge      PCIe PME, aerdrv
 125:     674114          0          0          0     705672       6110          0          0  IR-PCI-MSI 327680-edge      xhci_hcd
 126:          0         31          0          0          0          0          0          0  IR-PCI-MSI 360448-edge      mei_me
 127:     134097          0         31          0          0          0          0          0  INT344B:00   99  ETD2303:00
 128:          0          0          0         18          0          0          0          0  IR-PCI-MSI 1572864-edge      nvme0q0
 129:          0          0        250          0          0          0          0          0  IR-PCI-MSI 514048-edge      snd_hda_intel:card0
 130:          0          0          0          0      19088          0          0          0  IR-PCI-MSI 1572865-edge      nvme0q1
 131:          0       9431          0          0          0          0          0          0  IR-PCI-MSI 1572866-edge      nvme0q2
 132:          0          0       8073          0          0          0          0          0  IR-PCI-MSI 1572867-edge      nvme0q3
 133:          0          0          0       9255          0          0          0          0  IR-PCI-MSI 1572868-edge      nvme0q4
 134:          0          0          0          0          0       7961          0          0  IR-PCI-MSI 1572869-edge      nvme0q5
 135:          0          0          0          0          0          0      10062          0  IR-PCI-MSI 1572870-edge      nvme0q6
 136:       2222          0     381984          0      22229    1531873      27420       9994  IR-PCI-MSI 32768-edge      i915
 137:       1429        164         31        368       1196          0      12158      75506  IR-PCI-MSI 1048576-edge      iwlwifi
 138:         32          0         27          0          0          0         15          0  IR-PCI-MSI 524288-edge      nvkm
 139:          0          0          0          0          0          0          0       8193  IR-PCI-MSI 1572871-edge      nvme0q7
 NMI:         29         74         74         74         74         72         69         69   Non-maskable interrupts
 LOC:    1895402    1772361    1840003    1797418    1822740    2050418    1775710    1753250   Local timer interrupts
 SPU:          0          0          0          0          0          0          0          0   Spurious interrupts
 PMI:         29         74         74         74         74         72         69         69   Performance monitoring interrupts
 IWI:         93          5      22562          9       1329     107699       1915        540   IRQ work interrupts
 RTR:          0          0          0          0          0          0          0          0   APIC ICR read retries
 RES:     376738     205460     116961     102464      83042      65067      57540      53069   Rescheduling interrupts
 CAL:     171524     158205     159437     164110     160299     161635     165628     161995   Function call interrupts
 TLB:     232182     234240     233417     235103     225417     227488     230138     229758   TLB shootdowns
 TRM:          4          4          4          4          4          4          4          4   Thermal event interrupts
 THR:          0          0          0          0          0          0          0          0   Threshold APIC interrupts
 DFR:          0          0          0          0          0          0          0          0   Deferred Error APIC interrupts
 MCE:          0          0          0          0          0          0          0          0   Machine check exceptions
 MCP:         61         61         61         61         61         61         61         61   Machine check polls
 ERR:          0
 MIS:          0
 PIN:          0          0          0          0          0          0          0          0   Posted-interrupt notification event
 NPI:          0          0          0          0          0          0          0          0   Nested posted-interrupt event
 PIW:          0          0          0          0          0          0          0          0   Posted-interrupt wakeup event
```
才发现，IR-IO-APIC 后面都是添加上设备的，IR-PCI-MSI 主要是和 pcie 相关的设备，而 local apic 的名称直接被该 interrupt 的名字替代了。
- [ ] 1572869-edge : 是什么鬼

尝试分析一下 /proc/interrupts 如何生成的:
- 在 kernel/irq/proc.c::show_interrupts 中间

## matrix
观察到 linux/kernel/irq/matrix.c 以及 irq_alloc_matrix, 但是根本不知道为什么需要使用 matrix 这一个概念

## nested interrupt
- Interrupts	can	be	interrupted[^6]
  – By	different	interrupts;	handlers	need	not	be	reentrant
  – No	notion	of	priority	in	Linux
  – Small	portions	execute	with	interrupts	disabled
  – Interrupts	remain	pending	until	acked	by	CPU
- Exceptions	can	be	interrupted
  – By	interrupts	(devices	needing	service)
- Exceptions	can	nest	two	levels	deep
  – Exceptions	indicate	coding	error
  – Exception	code	(kernel	code)	shouldn’t	have	bugs
  – Pagefault	is	possible	(trying	to	touch	user	data)

In order to support as many architectures as possible, Linux has a more restrictive interrupt nesting implementation:[^7]
- an exception (e.g. page fault, system call) can not preempt an interrupt; if that occurs it is considered a bug
- an interrupt can preempt an exception or other interrupts; however, only one level of interrupt nesting is allowed

- [ ] 嵌套规则是 linux 规定的，还是 hardware, 如果是 os, 找到证据

## interrupt threads
- 感觉总是调用这个函数 : request_threaded_irq

## stack
- When	an	interrupt	occurs,	what	stack	is	used?	[^6]
  – **Exceptions**:	The	kernel	stack	of	the	current
  process,	whatever	it	is,	is	used		(There’s	always
  some	process	running	—	the	“idle”	process,	if
  nothing	else)
  – Interrupts:	hard	IRQ	stack	(1	per	processor)
  – SoftIRQs:	soa	IRQ	stack	(1	per	processor)
- These	stacks	are	configured	in	the	IDT	and	TSS at	boot	Wme	by	the	kernel

- [ ] 每一个 core 只是提供一个 stack 给 interrupts，在什么时候分配的
  - [ ] 配置在 IDT 和 TSS 中间, 验证一下
- [ ] 嵌套的 interrupts 是使用的不同的 stack 吗 ?
- [x] exception 是 process context 吗 ？ 不是

- [ ] https://unix.stackexchange.com/questions/491437/how-does-linux-kernel-switches-from-kernel-stack-to-interrupt-stack?rq=1
  - 这个回答说，如果发生在用户态，会进行两次 stack 切换，我是不信的
  - TSS 可以找到内核 stack, 那么靠什么找到 IRQ stack ?

## interrupt context
- [ ] [interrupt context and task context](https://stackoverflow.com/questions/22453739/why-do-we-need-interrupt-context)
- [ ] we already know why interrupt context is needed, but need more explanations for:
  - [ ] in_softirq
  - [ ] in_mni
  - [ ] ...
```c
/*
 * Are we doing bottom half or hardware interrupt processing?
 *
 * in_irq()       - We're in (hard) IRQ context
 * in_softirq()   - We have BH disabled, or are processing softirqs
 * in_interrupt() - We're in NMI,IRQ,SoftIRQ context or have BH disabled
 * in_serving_softirq() - We're in softirq context
 * in_nmi()       - We're in NMI context
 * in_task()	  - We're in task context
 *
 * Note: due to the BH disabled confusion: in_softirq(),in_interrupt() really
 *       should not be used in new code.
 */
#define in_irq()		(hardirq_count())
#define in_softirq()		(softirq_count())
#define in_interrupt()		(irq_count())
#define in_serving_softirq()	(softirq_count() & SOFTIRQ_OFFSET)
#define in_nmi()		(preempt_count() & NMI_MASK)
#define in_task()		(!(preempt_count() & \
				   (NMI_MASK | HARDIRQ_MASK | SOFTIRQ_OFFSET)))
```

## ret
- Interleaved	assemblyentry	points:	[^6]
  – ret_from_exception()
  – ret_from_intr()
  – ret_from_sys_call()
  – ret_from_fork()
- Things that happen:
  – Run	scheduler if	necessary
  – Return to user mode	if no	nested handlers
    - Restore	context, user-stack, switch	mode
    - Re-enable	interrupts if necessary
– Deliver	pending	signals

## ref
[^1]: https://www.oreilly.com/library/view/pc-hardware-in/059600513X/ch01s03s01s01.html
[^3]: Inside the Linux Virtualization : Principle and Implementation
[^4]: [kernel doc](https://0xax.gitbooks.io/linux-insides/content/Interrupts/)
[^5]: https://0xax.gitbooks.io/linux-insides/content/Interrupts/
[^6]: http://www.cs.columbia.edu/~krj/os/lectures/L07-LinuxEvents.pdf
[^7]: https://linux-kernel-labs.github.io/refs/heads/master/lectures/interrupts.html
[^8]: https://www.kernel.org/doc/html/latest/x86/kernel-stacks.html
