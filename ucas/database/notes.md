# one
几个概念:
1. 关系 : 二维表格
2. 属性 : 列
3. 元组 : 行
4. 度　 : 行的数目

关系模式一般表示为：关系名（属性1、……属性n）

完整性约束 : 键的属性取值不能为空 参考完整性 用户自定义完整性
> 参照完整性规则  关系R中外键的值或者为空值，或者为被参照关系中主键的值

布尔运算:
1. 运算基础: 同类关系
2. 交集　并集　差
3. 笛卡尔积 直接拼接起来
4. 补: 将可以取到的所有的属性然后减去，有效补的只对于关系r的属性取值构建全集而已。

3. 选择: 将元组(也就是行)抽出来，可以设置等于或者不等于之类
4. 投影: 将某一个属性抽出来
5. 连接:
    2. 自然连接 : 共同属性上的等值连接，其他的内容全部都是不需要的
    2. 或者指定连接的关系是什么 : 和自然连接不同的是，这会保留各自的属性，最典型的区别(等值链接和自然链接)
6. 除法: https://blog.csdn.net/t_1007/article/details/53036082
    1. 两个关系需要一个公共属性组Y
    2. 将除数R 分解为 X Y
    3. 然后查找X 中间那些对应所有Y的内容项目



# two

函数依赖:(描述其中 属性是键 ?)
r 是 R(U) 上的任意**关系**
> 等价描述

平凡依赖: Y 是 X 的子集， X-> Y 平凡的

函数依赖的推倒:
已知函数依赖集F，如何判断一个函数X→Y是否逻辑蕴涵于F ?
需要哪些推理法则（包括3个公理和3个推论）？
Armstrong公理（三个公理）：
自反律: X-> XY
增广律: 两边同时增加部分内容
传递律: X-> Y Y-> Z 那么X-> Z

有以上三个公理，可以推出以下3个推论
合成规则 : 推倒部分合成
分解规则 : 推到部分的任何子集也是完全确定的
伪传递规则 : 替换规则

除了基于推理的方法:

完全函数依赖，部分函数依赖

> 传递依赖为什么含有 x -\-> y 如果函数依赖的定义取消掉这一个限制，那么4NF的要求，部分含有非主属性的部分函数依赖，就会等价于不能出现函数依赖。
> 添加条件的原因就是防止退化为普通的函数依赖。


逻辑蕴涵

函数依赖集F的闭包 : 所有的函数依赖
属性集X的闭包 : 可以被X 全部依赖的全部内容

函数依赖集闭包及成员测试算法:
输入：属性集X和函数依赖集F
输出：X的闭包X+




1. 对于所有的函数依赖，只要函数依赖的左侧属于X, 那么扩张
> 似乎首先求解F 的闭包才可以啊，并不需要，其实在求解的过程中间就是在形成 F 的闭包

2. 判定F是否蕴涵X→Y的成员测试算法
> Y 属于 CLOSURE(X,F) 其实就是完全依赖于

由此，一共含有两种方法实现 求解函数依赖存在的方法

第一范式:

二范式: 函数
三范式: 传递依赖

数据库范式也分为1NF，2NF，3NF，BCNF，4NF，5NF。一般在我们设计关系型数据库的时候，最多考虑到BCNF就够。符合高一级范式的设计，必定符合低一级范式，例如符合2NF的关系模式，必定符合1NF。

”关系“是”关系模式“的一个实例，你可以把”关系”理解为一张带数据的表，而“关系模式”是这张数据表的表结构。

其改进是，2NF在1NF的基础之上，**消除了非主属性对于码的部分函数依赖**
> 1. 找到码
> 2. 找到非主属性
> 3. 判断 码采用部分属性就可以决定 非主属性
>
> 举一个例子:
> 1. 两个属性(学号，课程号)可以共同决定整个表格，但是课程号和学生出生年月没有任何关系


部分函数依赖: 和完全函数依赖相对的概念

**码** : 设 K 为某表中的一个属性或属性组，若除 K 之外的所有属性都完全函数依赖于 K（这个“完全”不要漏了），那么我们称 K 为候选码，简称为码。在实际中我们通常可以理解为：假如当 K 确定的情况下，该表除 K 之外的所有属性的值也就随之确定，那么 K 就是码。一张表中可以有超过一个码。（实际应用中为了方便，通常选择其中的一个码作为主码）
> 码 可以唯一决定所有的属性，候选码就是码，主码只是选择其中的一个
> 出现多个码

**非主属性** : 包含在任何一个码中的属性成为主属性。

**键** :  就是 **码**

**候选键** :  就是 **候选码**

**超键** :  只要可以唯一决定的就可以叫做超键，相对于码，超码没有要求完全依赖的要求
https://stackoverflow.com/questions/6951052/differences-between-key-superkey-minimal-superkey-candidate-key-and-primary-k

第三范式（3NF） 3NF在2NF的基础之上，**消除了非主属性对于码的传递函数依赖**。也就是说， 如果存在非主属性对于码的传递函数依赖，则不符合3NF的要求。
> 学号是码，可以决定学生姓名，系名，以及 系主任名称，那么系主任名称就就是对于学号的传递函数依赖

BCNF : 就是要在 3NF 的基础上**消除主属性对于码的部分与传递函数依赖.**
> 所以BCNF 的定义就是任何属性都不可以对于码的传递依赖。
> 还有一种说法: 出现A -> B(A B 没有交集)，那么A 必定是码
> 为什么会出现主属性的对于码的传递依赖啊!
若：某公司有若干个仓库；
每个仓库只能有一名管理员，一名管理员只能在一个仓库中工作；
一个仓库中可以存放多种物品，一种物品也可以存放在不同的仓库中。
每种物品在每个仓库中都有对应的数量。
那么关系模式 仓库（仓库名，管理员，物品名，数量） 属于哪一级范式？
答：
已知函数依赖集：仓库名 → 管理员，管理员 → 仓库名，（仓库名，物品名）→ 数量
码：（管理员，物品名），（仓库名，物品名）
主属性：仓库名、管理员、物品名
非主属性：数量
∵ 不存在非主属性对码的部分函数依赖和传递函数依赖。
∴ 此关系模式属于3NF。

> @todo 从2NF 3NF 知道，部分函数依赖 和 传递函数依赖 比更加宽泛啊! 所以当一个表中间不存在任何对于码的传递和部分函数依赖

https://www.zhihu.com/question/24696366
> 如果主属性得到对于码含有依赖部分依赖，必定是含有多个码才可以，其中的一个码对于另一个码含有部分依赖。



使用逆反命题的方法证明命题。
1. 证明2NF 属于 3NF 的方法: 非主属性 A 依赖于 K , 那么可以构建 K' 依赖于 K , 从而A 传递依赖于 K


分解，只要满足属性并联起来一致即可。

关系模式的规范化:

属性拆分导致当前可以获取多个关系.

> 分析不会导致信息减少，而会出现自然链接之后


判断当前的分解是不是无损连接:
1. 建立一个表: 每一个行对应关系，每一列对应属性
2. 然后对于所有的函数关系一一分析，首先将函数依赖X-> Y 涉及到从表格中间抽出来，分为左侧和右侧，其中左侧的内容相同的划分组，每组对应的右侧使用，如果那一列中间出现a, 全部替换为a, 否侧替换为最上层的b
当函数关系的左侧在表格相同的, 对于每一个关系的操作:

> https://blog.csdn.net/suguoliang/article/details/80880923
> 找一个有损连接的: 分解的含义，根据其中分解中间的一个个子集 对于 原来关系做投影，相当于将原来表格中间的子表格，然后将这些子表格自然链接，
> 自然链接要求数值相等的操作, 其实就是项目中间的内容增多了


LOSSNESS算法能正确判断分解是否是无损分解:
> 其实我们并没有证明这一个算法

F 在 Ri 上的投影: 依赖关系的两端都在 Ri 中间

由关系模式R上的函数依赖组成的集合F称为R上的函数依赖集，记为： FDs 应该就是不是所有的函数依赖

函数依赖的等价和覆盖 : 实际上就是描述函数依赖集合大小关系的

保持函数依赖集 : 分解之后，原来的函数依赖必须落在这些子集中间

检验分解ρ是否具有依赖保持性 : 划分为两个步骤
1. 计算F 在 ρ 上的投影 : G
2. 比较F 和 G 是否等价


> 其实很简单的内容，就是分析每一个函数依赖在每一个分解上还保留多少，所以如果X 不属于Ri， 那么肯定在该分解的子关系中间没有任何函数依赖，其中包含了去除平反依赖的内容。

候选键: 寻找候选键的一般算法是什么 ? 可以决定就是候选码，码和属性是两个东西
> 查找候选键的一般方法是是什么？


生成3NF 算法:

生成BCNF 算法:


# three
E-R图模型: 实体，属性，联系

@todo ER图中间设置的限制如何表示

@todo 似乎ER图还会转化为 ?

一个实体型转换为一个关系模式的转换规则

一般3NF即可
> 不同的范式主要为了处理什么异常

设计用户子模式，只是为了让不同的用户实现不同的内容。

数据库的物理设计: 索引方法　聚簇方法

* 模式 （亦称逻辑模式）
* 外模式 （亦称子模式）
* 内模式 （亦称存储模式）

二级映象功能与数据独立性


# four
> 介绍了分布式数据库的基本概念 透明性

分布式查询优化
分布式事务管理

> 半连接

可串行化

丢失修改
不可重复读
读"脏"数据

分布式事务的恢复

故障分类 和 恢复的方法

分布式目录: SDD-1 System R Oracle

数据库的安全机制
