# 用于大型程序的工具

- 如果继承多个基类的构造函数，并且其中存在构造函数的参数列表完全相同，那么必须定义自己的构造函数阻止二义性

- 编译器不会在派生类向基类的几种转换中进行比较和选择，在它看来都是一样好，所以如果出现多种选择，那么就会触发二义性错误

- 与只有基类的对象相同，对象，指针和引用的静态类型决定了我们能够使用那些成员。

- 多重继承导致类作用域的搜索可以同时在多个基类中间进行，因此会出现二义性错误，可以显示的指出，但是最好还是重新定义一次

```cpp
class A {
private:
  void get() { cout << "c" << endl; }
};

class B {
public:
  void get() { cout << "c" << endl; }
};

class C : public A, public B {};

int main(int argc, char *argv[]) {
  C c;

  c.B::get();
  return 0;
}
```

- 虚基类总是先于非虚基类初始化，如果一个类中间存在多个虚基类，那么按照在派生列表中间出现的顺序决定。
