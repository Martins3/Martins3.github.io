# 泛型算法

lambda 的唯一挑战应该就在于数值捕获吧
可能你还不太会使用 Lambda，基本形式如下：
```cpp
[](argument1,argument2,.....)-> return_type {//code}
```
在 () 中传入参数，在 {} 中编写代码，[] 是一个捕获列表，可以指定外部作用域中，可以使用的局部变量：
1. [] — 捕获列表为空，表示在 lambda 表达式中不能使用任何外部作用域的局部变量，只能使用传进去的参数。
2. [=] — 表示按照值传递的方法捕获父作用域的所有变量。
3. [&] — 表示按照引用传递的方法捕获父作用域的所有变量。
4. [this] — 在成员函数中，按照值传递的方法捕获 this 指针。
5. [a, &b] — 不建议直接使用 [=] 或 [&] 捕获所有变量，可以按需显式捕获，就是在 [] 指定变量名，[a] 表示值传递，[&b] 表示引用传递。

- 可以忽略参数和返回值, 比如
```cpp
  auto f = [] { return 42; };
```

- 一个 lambda 表达式只能使用那些明确指明的局部变量变量

- lambda 表达式在创建的时候，其实是在创建一个隐藏的对象，并且该对象定义了一个 () 操作符
- 之所以 lambda 需要对于局部变量进行 explicit 的捕获，是因为 lambda 再次被使用的时候，这些变量可能都不存在了
  - 当然捕获局部变量的 reference 需要自己注意
  - https://stackoverflow.com/questions/24474957/why-lambda-captures-only-automatic-storage-variables
